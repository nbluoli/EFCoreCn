---
title: Explicit values for generated properties | Microsoft Docs
author: rowanmiller
ms.author: divega
ms.date: 10/27/2016
ms.assetid: 3f1993c2-cdf5-425b-bac2-a2665a20322b
ms.technology: entity-framework-core
uid: core/saving/explicit-values-generated-properties
---
#生成属性的显式值 
# Explicit values for generated properties

生成属性是指当实体添加和/或更新时，其值（EF或数据库）生成的属性。更多信息见[Generated Properties](../modeling/generated-properties.html)。

A generated property is a property whose value is generated (either by EF or the database) when the entity is added and/or updated. See [Generated Properties](../modeling/generated-properties.html) for more information.

有些情况下，您希望为生成属性设置显式值，而不是一个生成值。

There may be situations where you want to set an explicit value for a generated property, rather than having one generated.

> [!TIP]
> 你可以在GitHub上查看本文的[示例代码](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/Saving/Saving/ExplicitValuesGenerateProperties/)。

> You can view this article's [sample](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/Saving/Saving/ExplicitValuesGenerateProperties/) on GitHub.

## The model

本文中使用的模型包含一个`Employee`实体。

The model used in this article contains a single `Employee` entity.
````csharp
		public class Employee
		{
			public int EmployeeId { get; set; }
			public string Name { get; set; }
			public DateTime EmploymentStarted { get; set; }
			public int Salary { get; set; }
			public DateTime? LastPayRaise { get; set; }
		}
````

## Saving an explicit value during add

在数据插入一个新实体时，`Employee.EmploymentStarted`属性通过配置，将得到生成值（使用默认值）。

The `Employee.EmploymentStarted` property is configured to have values generated by the database for new entities (using a default value).

```csharp
	modelBuilder.Entity<Employee>()
    .Property(b => b.EmploymentStarted)
    .HasDefaultValueSql("CONVERT(date, GETDATE())");
```

下面的代码将两个雇员插入数据库。

The following code inserts two employees into the database.

*第一个，没有值分配给`Employee.EmploymentStarted`属性，所以它仍然设置为CLR默认值给`DateTime`。

* For the first, no value is assigned to `Employee.EmploymentStarted` property, so it remains set to the CLR default value for `DateTime`.

*第一个，我们设置了一个显示值`1-Jan-2000`。

* For the second, we have set an explicit value of `1-Jan-2000`.

```csharp
using (var db = new EmployeeContext())
{
    db.Employees.Add(new Employee { Name = "John Doe" });
    db.Employees.Add(new Employee { Name = "Jane Doe", EmploymentStarted = new DateTime(2000, 1, 1) });
    db.SaveChanges();

    foreach (var employee in db.Employees)
    {
        Console.WriteLine(employee.EmployeeId + ": " + employee.Name + ", " + employee.EmploymentStarted);
    }
}
```
数据库输出显示，第一个雇员为生成值，第二个为显示值。
Output shows that the database generated a value for the first employee and our explicit value was used for the second.

````
1: John Doe, 1/26/2017 12:00:00 AM
2: Jane Doe, 1/1/2000 12:00:00 AM
````

### Explicit values into SQL Server IDENTITY columns

按照约定，`Employee.EmployeeId`属性是存储生成`IDENTITY`列。

By convention the `Employee.EmployeeId` property is a store generated `IDENTITY` column.

对于大多数情况，上面显示的方法将适用于主键属性。然而，在SQL Server`IDENTITY` 列中可以插入显式值，在调用`SaveChanges()`之前你需要手动启用`IDENTITY_INSERT`。

For most situations, the approach shown above will work for key properties. However, to insert explicit values into a SQL Server `IDENTITY` column, you need to manually enable `IDENTITY_INSERT` before calling `SaveChanges()`.

> [!NOTE]
>  SQL Server提供程序上，我们的待办事项上有一个[feature request](https://github.com/aspnet/EntityFramework/issues/703)去做这种自动。

> We have a [feature request](https://github.com/aspnet/EntityFramework/issues/703) on our backlog to do this automatically within the SQL Server provider.

```csharp
using (var db = new EmployeeContext())
{
    db.Employees.Add(new Employee { EmployeeId = 100, Name = "John Doe" });
    db.Employees.Add(new Employee { EmployeeId = 101, Name = "Jane Doe" });

    db.Database.OpenConnection();
    try
    {
        db.Database.ExecuteSqlCommand("SET IDENTITY_INSERT dbo.Employees ON");
        db.SaveChanges();
        db.Database.ExecuteSqlCommand("SET IDENTITY_INSERT dbo.Employees OFF");
    }
    finally
    {
        db.Database.CloseConnection();
    }


    foreach (var employee in db.Employees)
    {
        Console.WriteLine(employee.EmployeeId + ": " + employee.Name);
    }
}
```
输出显示所提供的ids保存到数据库中了。

Output shows that the supplied ids were saved to the database.

````
100: John Doe
101: Jane Doe
````
## 在更新时，设置一个显示值

## Setting an explicit value during update

在数据库更新时，`Employee.LastPayRaise`属性配置有值生成。

The `Employee.LastPayRaise` property is configured to have values generated by the database during updates.

<!--[!code-csharp[Main](../../../samples/core/Saving/Saving/ExplicitValuesGenerateProperties/EmployeeContext.cs#LastPayRaise)]-->
```csharp
modelBuilder.Entity<Employee>()
    .Property(b => b.LastPayRaise)
    .ValueGeneratedOnAddOrUpdate();

modelBuilder.Entity<Employee>()
    .Property(b => b.LastPayRaise)
    .Metadata.IsReadOnlyAfterSave = false;
```

> [!NOTE]

> 默认情况下，EF Core将抛出以下异常，如果你试图保存一个显式值的属性被配置为在更新过程中生成。为了避免这种情况，你需要降低元数据API的级别，并设置`IsReadOnlyAfterSave`标志（如上所示）。

> By default, EF Core will throw the following exception if you try to save an explicit value for a property that is configured to be generated during update. To avoid this, you need to drop down to the lower level metadata API and set the `IsReadOnlyAfterSave` flag (as shown above).
> 
> `System.InvalidOperationException The property 'LastPayRaise' on entity type 'Employee' is defined to be read-only after it has been saved, but its value has been modified or marked as modified.`

还可以在数据库的触发器在`UPDATE`操作期间为`LastPayRaise`生成值。

There is also a trigger in the database to generate values for the `LastPayRaise` column during `UPDATE` operations.

<!--[!code-sql[Main](../../../samples/core/Saving/Saving/ExplicitValuesGenerateProperties/employee_UPDATE.sql)]-->
```sql
CREATE TRIGGER [dbo].[Employees_UPDATE] ON [dbo].[Employees]
	AFTER UPDATE
AS
BEGIN
	SET NOCOUNT ON;
                  
	IF ((SELECT TRIGGER_NESTLEVEL()) > 1) RETURN;
                  
	IF UPDATE(Salary) AND NOT Update(LastPayRaise)
	BEGIN
		DECLARE @Id INT
		DECLARE @OldSalary INT
		DECLARE @NewSalary INT
          
		SELECT @Id = INSERTED.EmployeeId, @NewSalary = Salary        
		FROM INSERTED
          
		SELECT @OldSalary = Salary        
		FROM deleted
          
		IF @NewSalary > @OldSalary
		BEGIN
			UPDATE dbo.Employees
			SET LastPayRaise = CONVERT(date, GETDATE())
			WHERE EmployeeId = @Id
		END
	END
END
```
下面的代码增加了数据库中两名员工的工资。

The following code increases the salary of two employees in the database.

* 对于第一个，没有值被分配给`Employee.LastPayRaise`属性，所以它仍然设置为null。

* For the first, no value is assigned to `Employee.LastPayRaise` property, so it remains set to null.

* 对于第二个，我们给设设置了一个星期前的显示值（回溯加薪）。

* For the second, we have set an explicit value of one week ago (back dating the pay raise).

<!--[!code-csharp[Main](../../../samples/core/Saving/Saving/ExplicitValuesGenerateProperties/Sample.cs#LastPayRaise)]-->
```csharp
using (var db = new EmployeeContext())
{
    var john = db.Employees.Single(e => e.Name == "John Doe");
    john.Salary = 200;

    var jane = db.Employees.Single(e => e.Name == "Jane Doe");
    jane.Salary = 200;
    jane.LastPayRaise = DateTime.Today.AddDays(-7);

    db.SaveChanges();

    foreach (var employee in db.Employees)
    {
        Console.WriteLine(employee.EmployeeId + ": " + employee.Name + ", " + employee.LastPayRaise);
    }
}
```
数据库输出显示第一个雇员为生成值，第二个为显式值。

Output shows that the database generated a value for the first employee and our explicit value was used for the second.

````
1: John Doe, 1/26/2017 12:00:00 AM
2: Jane Doe, 1/19/2017 12:00:00 AM
````
